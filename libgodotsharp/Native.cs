//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

namespace GDExtension
{
	using System.Runtime.InteropServices;

	public static unsafe class Native
	{
		/// <summary>
		/// VARIANT TYPES
		/// </summary>
		public enum GDExtensionVariantType : int
		{
			GDEXTENSION_VARIANT_TYPE_NIL,

			/// <summary>
			/// atomic types
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_BOOL,

			/// <summary>
			/// atomic types
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_INT,

			/// <summary>
			/// atomic types
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_FLOAT,

			/// <summary>
			/// atomic types
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_STRING,

			/// <summary>
			/// math types
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_VECTOR2,

			/// <summary>
			/// math types
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_VECTOR2I,

			/// <summary>
			/// math types
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_RECT2,

			/// <summary>
			/// math types
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_RECT2I,

			/// <summary>
			/// math types
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_VECTOR3,

			/// <summary>
			/// math types
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_VECTOR3I,

			/// <summary>
			/// math types
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_TRANSFORM2D,

			/// <summary>
			/// math types
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_VECTOR4,

			/// <summary>
			/// math types
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_VECTOR4I,

			/// <summary>
			/// math types
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_PLANE,

			/// <summary>
			/// math types
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_QUATERNION,

			/// <summary>
			/// math types
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_AABB,

			/// <summary>
			/// math types
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_BASIS,

			/// <summary>
			/// math types
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_TRANSFORM3D,

			/// <summary>
			/// math types
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_PROJECTION,

			/// <summary>
			/// misc types
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_COLOR,

			/// <summary>
			/// misc types
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_STRING_NAME,

			/// <summary>
			/// misc types
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_NODE_PATH,

			/// <summary>
			/// misc types
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_RID,

			/// <summary>
			/// misc types
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_OBJECT,

			/// <summary>
			/// misc types
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_CALLABLE,

			/// <summary>
			/// misc types
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_SIGNAL,

			/// <summary>
			/// misc types
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_DICTIONARY,

			/// <summary>
			/// misc types
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_ARRAY,

			/// <summary>
			/// typed arrays
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_PACKED_BYTE_ARRAY,

			/// <summary>
			/// typed arrays
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_PACKED_INT32_ARRAY,

			/// <summary>
			/// typed arrays
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_PACKED_INT64_ARRAY,

			/// <summary>
			/// typed arrays
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_PACKED_FLOAT32_ARRAY,

			/// <summary>
			/// typed arrays
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_PACKED_FLOAT64_ARRAY,

			/// <summary>
			/// typed arrays
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_PACKED_STRING_ARRAY,

			/// <summary>
			/// typed arrays
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR2_ARRAY,

			/// <summary>
			/// typed arrays
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR3_ARRAY,

			/// <summary>
			/// typed arrays
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_PACKED_COLOR_ARRAY,

			/// <summary>
			/// typed arrays
			/// </summary>
			GDEXTENSION_VARIANT_TYPE_VARIANT_MAX,
		}

		public enum GDExtensionVariantOperator : int
		{
			/// <summary>
			/// comparison
			/// </summary>
			GDEXTENSION_VARIANT_OP_EQUAL,

			/// <summary>
			/// comparison
			/// </summary>
			GDEXTENSION_VARIANT_OP_NOT_EQUAL,

			/// <summary>
			/// comparison
			/// </summary>
			GDEXTENSION_VARIANT_OP_LESS,

			/// <summary>
			/// comparison
			/// </summary>
			GDEXTENSION_VARIANT_OP_LESS_EQUAL,

			/// <summary>
			/// comparison
			/// </summary>
			GDEXTENSION_VARIANT_OP_GREATER,

			/// <summary>
			/// comparison
			/// </summary>
			GDEXTENSION_VARIANT_OP_GREATER_EQUAL,

			/// <summary>
			/// mathematic
			/// </summary>
			GDEXTENSION_VARIANT_OP_ADD,

			/// <summary>
			/// mathematic
			/// </summary>
			GDEXTENSION_VARIANT_OP_SUBTRACT,

			/// <summary>
			/// mathematic
			/// </summary>
			GDEXTENSION_VARIANT_OP_MULTIPLY,

			/// <summary>
			/// mathematic
			/// </summary>
			GDEXTENSION_VARIANT_OP_DIVIDE,

			/// <summary>
			/// mathematic
			/// </summary>
			GDEXTENSION_VARIANT_OP_NEGATE,

			/// <summary>
			/// mathematic
			/// </summary>
			GDEXTENSION_VARIANT_OP_POSITIVE,

			/// <summary>
			/// mathematic
			/// </summary>
			GDEXTENSION_VARIANT_OP_MODULE,

			/// <summary>
			/// mathematic
			/// </summary>
			GDEXTENSION_VARIANT_OP_POWER,

			/// <summary>
			/// bitwise
			/// </summary>
			GDEXTENSION_VARIANT_OP_SHIFT_LEFT,

			/// <summary>
			/// bitwise
			/// </summary>
			GDEXTENSION_VARIANT_OP_SHIFT_RIGHT,

			/// <summary>
			/// bitwise
			/// </summary>
			GDEXTENSION_VARIANT_OP_BIT_AND,

			/// <summary>
			/// bitwise
			/// </summary>
			GDEXTENSION_VARIANT_OP_BIT_OR,

			/// <summary>
			/// bitwise
			/// </summary>
			GDEXTENSION_VARIANT_OP_BIT_XOR,

			/// <summary>
			/// bitwise
			/// </summary>
			GDEXTENSION_VARIANT_OP_BIT_NEGATE,

			/// <summary>
			/// logic
			/// </summary>
			GDEXTENSION_VARIANT_OP_AND,

			/// <summary>
			/// logic
			/// </summary>
			GDEXTENSION_VARIANT_OP_OR,

			/// <summary>
			/// logic
			/// </summary>
			GDEXTENSION_VARIANT_OP_XOR,

			/// <summary>
			/// logic
			/// </summary>
			GDEXTENSION_VARIANT_OP_NOT,

			/// <summary>
			/// containment
			/// </summary>
			GDEXTENSION_VARIANT_OP_IN,

			/// <summary>
			/// containment
			/// </summary>
			GDEXTENSION_VARIANT_OP_MAX,
		}

		/// <summary>
		/// VARIANT DATA I/O
		/// </summary>
		public enum GDExtensionCallErrorType : int
		{
			GDEXTENSION_CALL_OK,

			GDEXTENSION_CALL_ERROR_INVALID_METHOD,

			/// <summary>
			/// Expected a different variant type.
			/// </summary>
			GDEXTENSION_CALL_ERROR_INVALID_ARGUMENT,

			/// <summary>
			/// Expected lower number of arguments.
			/// </summary>
			GDEXTENSION_CALL_ERROR_TOO_MANY_ARGUMENTS,

			/// <summary>
			/// Expected higher number of arguments.
			/// </summary>
			GDEXTENSION_CALL_ERROR_TOO_FEW_ARGUMENTS,

			GDEXTENSION_CALL_ERROR_INSTANCE_IS_NULL,

			/// <summary>
			/// Used for const call.
			/// </summary>
			GDEXTENSION_CALL_ERROR_METHOD_NOT_CONST,
		}

		/// <summary>
		/// Method
		/// </summary>
		public enum GDExtensionClassMethodFlags : int
		{
			GDEXTENSION_METHOD_FLAG_NORMAL = unchecked((int)1),

			GDEXTENSION_METHOD_FLAG_EDITOR = unchecked((int)2),

			GDEXTENSION_METHOD_FLAG_CONST = unchecked((int)4),

			GDEXTENSION_METHOD_FLAG_VIRTUAL = unchecked((int)8),

			GDEXTENSION_METHOD_FLAG_VARARG = unchecked((int)16),

			GDEXTENSION_METHOD_FLAG_STATIC = unchecked((int)32),

			GDEXTENSION_METHOD_FLAGS_DEFAULT = unchecked((int)GDEXTENSION_METHOD_FLAG_NORMAL),
		}

		public enum GDExtensionClassMethodArgumentMetadata : int
		{
			GDEXTENSION_METHOD_ARGUMENT_METADATA_NONE,

			GDEXTENSION_METHOD_ARGUMENT_METADATA_INT_IS_INT8,

			GDEXTENSION_METHOD_ARGUMENT_METADATA_INT_IS_INT16,

			GDEXTENSION_METHOD_ARGUMENT_METADATA_INT_IS_INT32,

			GDEXTENSION_METHOD_ARGUMENT_METADATA_INT_IS_INT64,

			GDEXTENSION_METHOD_ARGUMENT_METADATA_INT_IS_UINT8,

			GDEXTENSION_METHOD_ARGUMENT_METADATA_INT_IS_UINT16,

			GDEXTENSION_METHOD_ARGUMENT_METADATA_INT_IS_UINT32,

			GDEXTENSION_METHOD_ARGUMENT_METADATA_INT_IS_UINT64,

			GDEXTENSION_METHOD_ARGUMENT_METADATA_REAL_IS_FLOAT,

			GDEXTENSION_METHOD_ARGUMENT_METADATA_REAL_IS_DOUBLE,
		}

		/// <summary>
		/// INITIALIZATION
		/// </summary>
		public enum GDExtensionInitializationLevel : int
		{
			GDEXTENSION_INITIALIZATION_CORE,

			GDEXTENSION_INITIALIZATION_SERVERS,

			GDEXTENSION_INITIALIZATION_SCENE,

			GDEXTENSION_INITIALIZATION_EDITOR,

			GDEXTENSION_MAX_INITIALIZATION_LEVEL,
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
		public partial struct GDExtensionCallError
		{
			public Native.GDExtensionCallErrorType error;

			public int argument;

			public int expected;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
		public partial struct GDExtensionInstanceBindingCallbacks
		{
			public Native.GDExtensionInstanceBindingCreateCallback create_callback;

			public Native.GDExtensionInstanceBindingFreeCallback free_callback;

			public Native.GDExtensionInstanceBindingReferenceCallback reference_callback;
		}

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void* GDExtensionInstanceBindingCreateCallback(void* p_token, void* p_instance);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionInstanceBindingFreeCallback(void* p_token, void* p_instance, void* p_binding);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate byte GDExtensionInstanceBindingReferenceCallback(void* p_token, void* p_binding, byte p_reference);

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
		public partial struct GDExtensionPropertyInfo
		{
			public Native.GDExtensionVariantType type;

			public void* name;

			public void* class_name;

			/// <summary>
			/// Bitfield of `PropertyHint` (defined in `extension_api.json`).
			/// </summary>
			public uint hint;

			public void* hint_string;

			/// <summary>
			/// Bitfield of `PropertyUsageFlags` (defined in `extension_api.json`).
			/// </summary>
			public uint usage;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
		public partial struct GDExtensionMethodInfo
		{
			public void* name;

			public Native.GDExtensionPropertyInfo return_value;

			/// <summary>
			/// Bitfield of `GDExtensionClassMethodFlags`.
			/// </summary>
			public uint flags;

			public int id;

			/// <summary>
			/// Arguments: `default_arguments` is an array of size `argument_count`.
			/// </summary>
			public uint argument_count;

			public void* arguments;

			/// <summary>
			/// Default arguments: `default_arguments` is an array of size `default_argument_count`.
			/// </summary>
			public uint default_argument_count;

			public void* default_arguments;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
		public partial struct GDExtensionClassCreationInfo
		{
			public byte is_virtual;

			public byte is_abstract;

			public IntPtr set_func;

			public IntPtr get_func;

			public IntPtr get_property_list_func;

			public IntPtr free_property_list_func;

			public IntPtr property_can_revert_func;

			public IntPtr property_get_revert_func;

			public IntPtr notification_func;

			public IntPtr to_string_func;

			public IntPtr reference_func;

			public IntPtr unreference_func;

			/// <summary>
			/// (Default) constructor; mandatory. If the class is not instantiable, consider making it virtual or abstract.
			/// </summary>
			public IntPtr create_instance_func;

			/// <summary>
			/// Destructor; mandatory.
			/// </summary>
			public IntPtr free_instance_func;

			/// <summary>
			/// Queries a virtual function by name and returns a callback to invoke the requested virtual function.
			/// </summary>
			public IntPtr get_virtual_func;

			public IntPtr get_rid_func;

			/// <summary>
			/// Per-class user data, later accessible in instance bindings.
			/// </summary>
			public void* class_userdata;
		}

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate byte GDExtensionClassSet(void* p_instance, void* p_name, void* p_value);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate byte GDExtensionClassGet(void* p_instance, void* p_name, void* r_ret);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void* GDExtensionClassGetPropertyList(void* p_instance,  uint* r_count);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionClassFreePropertyList(void* p_instance, in Native.GDExtensionPropertyInfo p_list);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate byte GDExtensionClassPropertyCanRevert(void* p_instance, void* p_name);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate byte GDExtensionClassPropertyGetRevert(void* p_instance, void* p_name, void* r_ret);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionClassNotification(void* p_instance, int p_what);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionClassToString(void* p_instance,  byte* r_is_valid, void* p_out);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionClassReference(void* p_instance);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionClassUnreference(void* p_instance);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void* GDExtensionClassCreateInstance(void* p_userdata);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionClassFreeInstance(void* p_userdata, void* p_instance);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate Native.GDExtensionClassCallVirtual GDExtensionClassGetVirtual(void* p_userdata, void* p_name);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionClassCallVirtual(void* p_instance,  void** p_args, void* r_ret);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate ulong GDExtensionClassGetRID(void* p_instance);

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
		public partial struct GDExtensionClassMethodInfo
		{
			public void* name;

			public void* method_userdata;

			public IntPtr call_func;

			public IntPtr ptrcall_func;

			/// <summary>
			/// Bitfield of `GDExtensionClassMethodFlags`.
			/// </summary>
			public uint method_flags;

			/// <summary>
			/// If `has_return_value` is false, `return_value_info` and `return_value_metadata` are ignored.
			/// </summary>
			public byte has_return_value;

			public void* return_value_info;

			public Native.GDExtensionClassMethodArgumentMetadata return_value_metadata;

			/// <summary>
			/// Arguments: `arguments_info` and `arguments_metadata` are array of size `argument_count`.
			/// Name and hint information for the argument can be omitted in release builds. Class name should always be present if it applies.
			/// </summary>
			public uint argument_count;

			public void* arguments_info;

			public void* arguments_metadata;

			/// <summary>
			/// Default arguments: `default_arguments` is an array of size `default_argument_count`.
			/// </summary>
			public uint default_argument_count;

			public void* default_arguments;
		}

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionClassMethodCall(void* method_userdata, void* p_instance,  void** p_args, long p_argument_count, void* r_return,  Native.GDExtensionCallError* r_error);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionClassMethodPtrCall(void* method_userdata, void* p_instance,  void** p_args, void* r_ret);

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
		public partial struct GDExtensionScriptInstanceInfo
		{
			public Native.GDExtensionScriptInstanceSet set_func;

			public Native.GDExtensionScriptInstanceGet get_func;

			public Native.GDExtensionScriptInstanceGetPropertyList get_property_list_func;

			public Native.GDExtensionScriptInstanceFreePropertyList free_property_list_func;

			public Native.GDExtensionScriptInstancePropertyCanRevert property_can_revert_func;

			public Native.GDExtensionScriptInstancePropertyGetRevert property_get_revert_func;

			public Native.GDExtensionScriptInstanceGetOwner get_owner_func;

			public Native.GDExtensionScriptInstanceGetPropertyState get_property_state_func;

			public Native.GDExtensionScriptInstanceGetMethodList get_method_list_func;

			public Native.GDExtensionScriptInstanceFreeMethodList free_method_list_func;

			public Native.GDExtensionScriptInstanceGetPropertyType get_property_type_func;

			public Native.GDExtensionScriptInstanceHasMethod has_method_func;

			public Native.GDExtensionScriptInstanceCall call_func;

			public Native.GDExtensionScriptInstanceNotification notification_func;

			public Native.GDExtensionScriptInstanceToString to_string_func;

			public Native.GDExtensionScriptInstanceRefCountIncremented refcount_incremented_func;

			public Native.GDExtensionScriptInstanceRefCountDecremented refcount_decremented_func;

			public Native.GDExtensionScriptInstanceGetScript get_script_func;

			public Native.GDExtensionScriptInstanceIsPlaceholder is_placeholder_func;

			public Native.GDExtensionScriptInstanceSet set_fallback_func;

			public Native.GDExtensionScriptInstanceGet get_fallback_func;

			public Native.GDExtensionScriptInstanceGetLanguage get_language_func;

			public Native.GDExtensionScriptInstanceFree free_func;
		}

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate byte GDExtensionScriptInstanceSet(void* p_instance, void* p_name, void* p_value);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate byte GDExtensionScriptInstanceGet(void* p_instance, void* p_name, void* r_ret);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void* GDExtensionScriptInstanceGetPropertyList(void* p_instance,  uint* r_count);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionScriptInstanceFreePropertyList(void* p_instance, in Native.GDExtensionPropertyInfo p_list);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate byte GDExtensionScriptInstancePropertyCanRevert(void* p_instance, void* p_name);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate byte GDExtensionScriptInstancePropertyGetRevert(void* p_instance, void* p_name, void* r_ret);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void* GDExtensionScriptInstanceGetOwner(void* p_instance);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionScriptInstanceGetPropertyState(void* p_instance, Native.GDExtensionScriptInstancePropertyStateAdd p_add_func, void* p_userdata);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionScriptInstancePropertyStateAdd(void* p_name, void* p_value, void* p_userdata);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void* GDExtensionScriptInstanceGetMethodList(void* p_instance,  uint* r_count);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionScriptInstanceFreeMethodList(void* p_instance, in Native.GDExtensionMethodInfo p_list);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate Native.GDExtensionVariantType GDExtensionScriptInstanceGetPropertyType(void* p_instance, void* p_name,  byte* r_is_valid);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate byte GDExtensionScriptInstanceHasMethod(void* p_instance, void* p_name);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionScriptInstanceCall(void* p_self, void* p_method,  void** p_args, long p_argument_count, void* r_return,  Native.GDExtensionCallError* r_error);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionScriptInstanceNotification(void* p_instance, int p_what);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionScriptInstanceToString(void* p_instance, byte* r_is_valid, void* r_out);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionScriptInstanceRefCountIncremented(void* p_instance);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate byte GDExtensionScriptInstanceRefCountDecremented(void* p_instance);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void* GDExtensionScriptInstanceGetScript(void* p_instance);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate byte GDExtensionScriptInstanceIsPlaceholder(void* p_instance);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void* GDExtensionScriptInstanceGetLanguage(void* p_instance);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionScriptInstanceFree(void* p_instance);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate IntPtr GDExtensionInterfaceGetProcAddress(string p_function_name);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionInterfaceFunctionPtr();	

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionVariantFromTypeConstructorFunc(void* arg0, void* arg1);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionTypeFromVariantConstructorFunc(void* arg0, void* arg1);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionPtrOperatorEvaluator(void* p_left, void* p_right, void* r_result);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionPtrBuiltInMethod(void* p_base, void** p_args, void* r_return, int p_argument_count);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionPtrConstructor(void* p_base, void** p_args);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionPtrDestructor(void* p_base);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionPtrSetter(void* p_base, void* p_value);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionPtrGetter(void* p_base, void* r_value);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionPtrIndexedSetter(void* p_base, long p_index, void* p_value);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionPtrIndexedGetter(void* p_base, long p_index, void* r_value);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionPtrKeyedSetter(void* p_base, void* p_key, void* p_value);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionPtrKeyedGetter(void* p_base, void* p_key, void* r_value);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate uint GDExtensionPtrKeyedChecker(void* p_base, void* p_key);

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void GDExtensionPtrUtilityFunction(void* r_return, void** p_args, int p_argument_count);

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
		public struct GDExtensionInitialization
		{
			/// <summary>
			/// Minimum initialization level required.
			/// If Core or Servers, the extension needs editor or game restart to take effect
			/// </summary>
			public Native.GDExtensionInitializationLevel minimum_initialization_level;

			/// <summary>
			/// Up to the user to supply when initializing
			/// </summary>
			public void* userdata;

			/// <summary>
			/// This function will be called multiple times for each initialization level.
			/// </summary>
			public IntPtr initialize;

			[UnmanagedFunctionPointer(CallingConvention.StdCall)]
			public delegate void initialize_delegate(void* userdata, Native.GDExtensionInitializationLevel p_level);

			public IntPtr deinitialize;

			[UnmanagedFunctionPointer(CallingConvention.StdCall)]
			public delegate void deinitialize_delegate(void* userdata, Native.GDExtensionInitializationLevel p_level);
		}

	}
}
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
